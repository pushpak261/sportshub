




First we create spring project by spring initializer

Project -> Gradle
Language -> Java
Spring Boot -> 3.3.5

Project Metadata
---
Group : com.ecommerce
Artifact : sportshub
Name : sportshub
Description : Project on Sports Accessories
Package name : com.ecommerce.sportshub
Packaging : Jar
Java : 21

Dependencies
---
Spring Web
Lombok
MYSQL Driver
Spring Data JPA
Spring Security
Validation

then we open project on Intellij Idea or any other IDE

=============

Now we have to add some extra dependencies since we are going to be making use of AWS S3 Bucket.
and also dependency for our JSON web token.
jwt impl, jwt api, jwt jackson.

jwt dependency is used for generating token.

Now configure application.properties in this we write database connectivity.


LinuX Configuration:
---
sudo apt-get update
sudo apt-get install mysql-server
sudo systemctl status mysql

sudo mysql

First create database in mysql

create package structure:
---
controller
dto
enums
exception
mapper
repository
security
service
specification


Entity, Dto, Repository
----
first create entity


In entity create User
--
User.java
@Data is going to help to generate getters setters rather than writing it manually.
Table name is users

User is going to have id, name, email, password, phoneNumber, role, orderItemList, address, createdAt
address is going to be one to one relationship. That means user is going to have an address. An address is going to belong to a user.

CascadeType.All means whenever a user is deleted the address of that user is going to be deleted. Whenever the address of a user is updated is going to reflect on the user.
Now add one to many relationship to the order items. That means a user can have many orders.

Add some validations for name, phone number, password, email


UserRole.java
In enums create UserRole : ADMIN, USER


OrderStatus.java
In enums create OrderStatus : PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED, RETURNED


Address.java
Now we are going to have Address entity
Address is going to have id, street, city, state, zipCode, country, user, createdAt
For the user I am going to have many to one relationship. user Id is going to have a relationship to the user.


Category.java
Category is going to have fields like id, name, productList, createdAt.
we dont have 2 different categories with the same name so we make it unique to be True.
After this we are going to also map this to a product. We also want to be able to get the products from this category.


Product.java
Product is going to have fields like id, name, description, imageUrl, price, category, createdAt.
We are going to be storing our image ang going to store the URL here in our database.
The product belongs to category.
The date , time the product was created.
Category is going to have our relationship many to one. That means many products belong to one category and a category can have many products.
cascadeType.ALL means if a category is deleted, the products within it should also be removed. and if a product is updated it should reflect in our category.


Order.java
Order is going to have fields like id, totalPrice, orderItemList, createdAt.
id is a primary key.
For each order we are going to have the total price.
The date in which item was created which is going to be createdAt.
we are going to have one to many relationship that means one order have multiple order items. eg: see in cart page.
cascade means that if you delete an order, its going to delete the order items. if you have an order items its going to reflect in the order.
we can have our payment as well bcz we are making an order.
//Payment


OrderItem.java
OrderItem is going to have fields like id, quantity, price, status, user, product, order, createdAt.
Primary key is generated using the identity strategy.
An order item has an quantity.
For each order is going to have an OrderStatus.
User is going to be the one making an order. and it can have many to one relationship means many order items can a user order.
Product is what user is ordering. An order item is going to have product bcz we are actually ordering a product here. We have many to one relationship means one product can have multiple orders.
An order item is going to have an order.


Payment.java
Table name
Payment is going to have fields like id, amount, method, status, order, createdAt.
If you are creating an order and you are checking out an order, you should make payment. So for a payment we are going to check which order it was paid for.
we are going to have one to one relationship means one order can have one payment.


Review.java
Table name
Review is going to have fields like id, content, rating, product, user, createdAt.
For each product we want a user to be able to give feedback.
Content is basically the description of the user.
We are going to have many to one relationship that means a product can have multiple reviews.
We are also going to have a relationship for user which is many to one and at the same time a user is going to be the one making a user.
LocalDateTime which will detect at which date review was created.

-----X----X-----X-----



Now we are going to proceed to write our DTO.

AddressDto.java
AddressDto is going to have properties like id,  street, city, state, zipcode, country.
We dont want to return this so for that we dont want to return this address as it is.
so we want to have an DTO which is basically, you know, return.


CategoryDto.java
CategoryDto is going to have field like id, name, productList
@Data helps to generate our getter and setters.
@JsonInclude is going to ignore properties of fields that are null.
@AllArgsConstructor is helping to auto generate constructor.
@NoArgsConstructor in case we dont have constructor NoArgsConstructor is going to be called.


OrderDto.java
OrderDto is going to have properties like id, totalPrice, createdAt, orderItemList.
when we are creating an order, we just pass in the total price and order value.


OrderItemDto.java
OrderItemDto is going to have properties like id, quantity, price, status, user, product, createdAt
We are going to have quantity of product you want to order, price and status of the products, the date the products was created.


ProductDto.java
ProductDto is going to have fields like id, name, description, price, imageUrl, category.


UserDto.java
UserDto is going to have fields like id, email, name, phoneNumber, password, role, orderItemList, address

Note:
As we saw earlier we dont want to return the entity directly. So we want to map the entity to a DTO so we can easily control the date and kind of data that we need to output to a user.
For Eg: For the user  we can see over here in the user entity we are going to be having a password. And if I return this entity directly we are going to be returning the user's passwords as well.
But If I create an Dto of this and have a passwd, i can decide not to add the password fields over here. So I can decide to ignore this and just pass the necessary data that i need. So that the purpose of having Dto for each entity.

Now next we are going to create a response, a generic class for all our response. I dont want us to have an address response, a category.
I just want to have a generic response which we are going to be using to output all our responses.And that response is going to have some properties and some fields.


Response.java
Response is going to have fields like status, message, timestamp, token, role, expirationTime, totalPage, totalElement, address, user, userList, category, categoryList, product, productList, orderItem, orderItemList, order, orderList
@JsonInclude so what it does is that whatever properties we have here that doesnt have a value, we re going to ignore it.

Lets have HTTP status for every of our response. we want to have a status code. If its successful. If its not successful its an error. we want to have a status code.
And also have the date in which such request was sent out. timestamp.
So for every req I'm returning, I'm adding a timestamp to it.

No i am going to have Order field so this is going to be to when the user is successfully logged in. We want to have a token, to return a token. So this field is going to be used to capture the token that was generated by the user. So lets do it to capture the role and
also use this to capture the expiration time.
Next we want to create another properties to capture the total pages and the total elements Bcz in this application we are going to be using pagination.

We want to use pagination to select some certain data and return it on the on demand. So when we decide to use that we are going to be needing a page.

If we decide to return an address, lets just call the address. and if we decide to return a user data we are going to capture the user data (userDto)
If we want to return a list of users we are just going to call that user list.
At the same time we can return a category and categoryList. Same for product, orderItem and order.

Note:
So this is going to be our Generic Response class.
And for every response we want to pass in the status of that response the message and the timestamp.
And since this is going to be our generic response class @JSON, ignore is going to be used to whatever value that is not present here we are not going to be sending it.
For EG: if we are using this response to login a user we are only going to be expecting the status, message, timestamp, the token, the role and the expiration time.
We are not going to be expecting the totalPage, category and so bcz we have our JSON ignore over here its going to ignore these other fields that are not necessary.
At the same time if I am using this Response class to return lets say category is going to ignore these other fields that are null. So this is our generic response class.


LoginRequest.java
LoginRequest is going to have fields such as email and passwords and both fields are validated.
Login body - pass email and password to login .


OrderRequest.java
OrderRequest is going to have fields like totalPrice, items, paymentInfo.
//Create a body to be used to create an order
//If I click on checkOut in cart page I am going to bundle this data and I am going to calculate the total prices of all the data.
//And I am going to bundle them into an object & I am going to send it to the backend to create an order

So lets Create a class to be able to handle the data that is going to be used to create an order.

@JSON - so what it does if we are using this as our request, whatever fields are not passed in is going to be ignored.
Lets have a list of our orderItem. I am going to create an OrderItemRequest and lets just call this as items.

Note:
This class is going to collect data which is the totalPrice and each individual item is going to go over the order item req, which is going to be the List of items and the payment.


OrderItemRequest.java
OrderItemRequest is going to have fields like productId and quantity
Now lets create order item req here

Note:
Our order item req is going to be each of this product here we are going to pass in the ID and the quantity of the product. Eg: In cart page
it is feed into Order.java

-----X----X-----X-----


Lets Proceed to write our Repositories

AddressRepo.java
This is going to be interface which extends JPA Repository and we are passing Address entity and the data type of my primary key which is a long.


CategoryRepo.java
This is an interface which extends JPA Repository and we are passing category entity and the primary key of that entity which is a long.


OrderItemRepo.java
which is an interface and this extends JPA Repo and its going to take our OrderItem as entity and the primary key of that entity is long and
also for this I am going to using a specification which is our JPA specification which is going to pass in taking our order item.

Note:
Specification are kind of used to create custom query in a more flexible way. So it helps to create search queries on a given condition.
Advantages: It helps to reduce in and helps to shorten your code. It helps to create reusable codes.
Eg: Go to OrderItem entity. If I want to search an order by status, by userId, by product, by order i want to search an order by this fields. By using JPA
specification. I can just have one method which I can use to search by status, by user, or both of them, or product or both. Just one method provided that you pass in either of them.
So whatever you pass in is going to take that off and help you to filter. so that's what specification does.


OrderRepo.java
This is an interface which extends JPA Repository and we are passing out order entity and the primary key of this entity will be long.

Note:
Difference between Order and OrderItem;
So an orderItem is basically a product. Eg: In cart page each individual item in your order is an order item is basically a product that is being ordered. so thats an order item where an order is a
collection of order items.. like this is an order which has 4 or many order items  and each of these is an order item.


ProductRepo.java
This is an interface which extends JPA Repository and we are passing Product entity and the primary key of this entity is long.
In this we are going to have methods to search. Eg: I want to find all the products by categoryId so I can just say method findByCategory and pass fields like categoryId and datatype as long.
And we also need to search our products by name and description. so we have a method findByNameOrDescriptionContaining and pass fields like name and description in it from product entity.
//So with this JPA automatically going to search for a product that has name containing. Eg:Lets say I have a product whose name is vegan is a product. So with this if I pass ve like without passing full name completely its going to search a product that contains that name.
//Follow the naming convention as this is a JPA naming convention.


UserRepo.java
This is an interface which extends JPA Repository and we are passing User entity and the primary key is Long.
Here we use Optional for User. findByEmail method and pass email as a string in it. I am going to use this method to search user by email. as email is going to be the primary key of a user.



=========================







---

<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>s3</artifactId>
</dependency>
<dependency>
    <groupId>software.amazon.awssdk</groupId>
    <artifactId>auth</artifactId>
</dependency>


Mysql workbench, mysql server download, visual C++ 2019.
mysql -u root -p
username : root
password : cdac


